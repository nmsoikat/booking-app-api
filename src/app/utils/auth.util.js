'use strict';

const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { ErrorConstant } = require('../constants');
const env = process.env;

const AuthUtil = {
    /**
    * Generate a salt using bcrypt
    * @return {bcrypt salt} salt generated by bcrypt.
    */
    generateSalt: async (salt = 10) => {
        try {
            return await bcrypt.genSalt(salt)
        } catch (error) {
            throw new Error(ErrorConstant.BCRYPT_SALT_FAIL);
        }
    },

    /**
    * Convert user password to hashed password
    * @param {String} password
    * @param {bcrypt salt} salt
    * @return {String} hashed password
    */
    generateHashedPassword: async (password, salt) => {
        try {
            return await bcrypt.hash(password, salt)
        } catch (error) {
            throw new Error(ErrorConstant.HASH_GENERATE_FAIL);
        }
    },

    /**
    * Compare password with hashed password
    * @param {String} password
    * @param {String} hashedPassword
    * @return {Boolean} true/false
    */
    compareHashedPassword: async (password, hashedPassword) => {
        try {
            return await bcrypt.compare(password, hashedPassword)
        } catch (error) {
            throw new Error(ErrorConstant.BCRYPT_COMPARE_FAIL);
        }
    },

    /**
    * Get access token by providing payload and refresh token id.
    * @param {Object} payload
    * @param {String} refreshTokenId
    * @param {Boolean} is_admin default false
    * @return {Object} access token id and access token
    */
    generateAccessToken: async (payload = {}) => {
        try {
            const access_token = jwt.sign(
                payload,
                env.JWT_ACCESS_TOKEN_SECRET,
                {
                    expiresIn: env.JWT_ACCESS_TOKEN_EXPIRES_IN,
                }
            );

            return access_token
        } catch (error) {
            throw new Error(ErrorConstant.TOKEN_CREATION_FAIL);
        }
    }
}

module.exports = AuthUtil;